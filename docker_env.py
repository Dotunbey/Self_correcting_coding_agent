import docker
import tarfile
import io
import time

class CodeExecutionEnv:
    def __init__(self, image="python:3.9-slim", timeout=5):
        """
        A secure Docker sandbox for executing untrusted Python code.
        
        Args:
            image: The Docker image to use (default: python:3.9-slim).
            timeout: Execution timeout in seconds (default: 5s).
        """
        self.client = docker.from_env()
        self.image = image
        self.timeout = timeout
        
        # Pull the image immediately to avoid delays later
        try:
            print(f"üê≥ Checking for Docker image '{image}'...")
            self.client.images.get(image)
        except docker.errors.ImageNotFound:
            print(f"‚¨áÔ∏è Image not found. Pulling '{image}'...")
            self.client.images.pull(image)
            print("‚úÖ Image pulled.")

    def run(self, code: str, tests: str = "") -> tuple[str, bool]:
        """
        Executes the provided Python code in a disposable container.
        
        Args:
            code: The Python function generated by the LLM.
            tests: The unit test code (assert statements) to verify correctness.
            
        Returns:
            output (str): Captured stdout/stderr from the execution.
            passed (bool): True if execution succeeded and tests passed.
        """
        
        # Combine code and tests into a single executable string
        full_script = f"{code}\n\n# --- Unit Tests ---\n{tests}"
        
        # Create a container with strict security limits
        container = self.client.containers.run(
            self.image,
            command="python /app/script.py",
            detach=True,
            network_disabled=True,  # No internet access
            mem_limit="512m",       # Limit RAM
            cpu_period=100000,      # Limit CPU usage
            cpu_quota=50000,        # 50% of one core
            cap_drop=["ALL"],       # Drop all capabilities (no sudo/root stuff)
            working_dir="/app",
            tty=True 
        )

        try:
            # Inject the script into the running container
            self._copy_to_container(container, full_script, "/app/script.py")
            
            # Wait for the result with a timeout
            start_time = time.time()
            while container.status in ['created', 'running']:
                container.reload()
                if time.time() - start_time > self.timeout:
                    container.kill()
                    return "‚è±Ô∏è Execution Timed Out", False
                time.sleep(0.1)

            # Capture logs (stdout + stderr)
            logs = container.logs().decode("utf-8")
            exit_code = container.attrs['State']['ExitCode']
            
            return logs, (exit_code == 0)

        except Exception as e:
            return f"Docker Error: {str(e)}", False
            
        finally:
            # Always clean up the container
            container.remove(force=True)

    def _copy_to_container(self, container, content, path):
        """Helper to write a string to a file inside the container."""
        tar_stream = io.BytesIO()
        with tarfile.open(fileobj=tar_stream, mode='w') as tar:
            data = content.encode('utf-8')
            info = tarfile.TarInfo(name=path.split("/")[-1])
            info.size = len(data)
            tar.addfile(info, io.BytesIO(data))
        
        tar_stream.seek(0)
        container.put_archive(path.rsplit("/", 1)[0], tar_stream)

# --- Quick Test Block ---
if __name__ == "__main__":
    env = CodeExecutionEnv()
    
    # Test 1: Good Code
    print("\nüß™ Test 1: Valid Code")
    code = "def add(a, b): return a + b"
    test = "assert add(2, 3) == 5\nprint('Tests Passed!')"
    output, passed = env.run(code, test)
    print(f"Output: {output.strip()}")
    print(f"Passed: {passed}")

    # Test 2: Bad Code (Infinite Loop)
    print("\nüß™ Test 2: Infinite Loop (Timeout check)")
    bad_code = "while True: pass"
    output, passed = env.run(bad_code)
    print(f"Output: {output.strip()}")
    print(f"Passed: {passed}")
